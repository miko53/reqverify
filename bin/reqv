#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative '../lib/project'
require_relative '../lib/traca_gen'
require_relative '../lib/export_csv'
require_relative '../lib/export_xlsx'
require_relative '../lib/log'
require_relative '../lib/display_status_req'

# main application class
class Main
  EXIT_FAILURE = 1

  def initialize
    @working_dir = ''
    @output_folder = ''
    @project = nil
  end

  # main entry point function
  # read the command-line argument
  # check them
  # and execute requested action
  def main
    options = read_args
    check_options(options)
    initialize_log_level(options)
    @project = load_project_check_working_dir(options)
    return EXIT_FAILURE if @project.nil?

    parse_and_launch_action(options)
  end

  # This method read command-line arguments
  # and returns +options+ hash of argument
  def read_args # rubocop:disable Metrics/MethodLength, Metrics/AbcSize
    options = {}
    OptionParser.new do |opts| # rubocop:disable Metrics/BlockLength
      opts.banner = "Usage: #{$PROGRAM_NAME} "
      opts.on('-pPROJECT_FILE', '--project=PROJECT_FILE', 'provide project file') do |n|
        options[:project_file] = n
      end
      opts.on('-rRELATIONSHIP', '--relationship=RELATIONSHIP', 'concerned traceability to check/export') do |n|
        options[:relationship] = n
      end
      opts.on('-aACTION', '--action=ACTION', 'action to launch (status/export/list/clean)') do |n|
        options[:action] = n
      end
      opts.on('-DDOCUMENT', '--document=DOCUMENT', 'document to list requirement') do |n|
        options[:doc] = n
      end
      opts.on('-oOUTPUT_FOLDER', '--output-folder=OUTPUT_FOLDER', 'folder where stored result') do |n|
        options[:output_folder] = n
      end
      opts.on('-fOUTPUT_FILE', '--output-file=OUTPUT_FILE', 'file where stored result') do |n|
        options[:output_file] = n
      end
      opts.on('-FFORMAT', '--format-export=FORMAT', 'export file format csv,xlsx') do |n|
        options[:export_format] = n
      end
      opts.on('-LPLUGINS_PATH', '--plugins-path=PLUGINS_PATH', 'custom path of import plugins') do |n|
        options[:plugins_path] = n
      end
      opts.on('-d', '--[no-]debug', 'Run with debug info') do |n|
        options[:debug] = n
      end
      opts.on('-v', '--[no-]verbose', 'Run with verbose info') do |n|
        options[:verbose] = n
      end

      opts.on('-h', '--help', 'Print this help') do |n|
        puts opts
        puts '  Possible actions are: '
        puts '  - status, generate and display traceability status on output console'
        puts '  - export, generate and display traceability on file/folder given in argument'
        puts '  - list, list all requirement of a document'
        puts '  - clean, remove all intermediate file, to build again yaml requirement file'
        exit
      end
    end.parse!
    # pp options
    options
  end

  def initialize_log_level(options)
    Log.verbose_level = Log::LOG_LEVEL_NONE
    Log.verbose_level = Log::LOG_LEVEL_INFO unless options[:verbose].nil?
    Log.verbose_level = Log::LOG_LEVEL_DBG unless options[:debug].nil?
  end

  # check if given +options+ (hash data come from command-line)
  # are correct
  # return to shell if mandatory option are not given
  def check_options(options)
    failure = false

    if options[:action].nil?
      Log.error 'need to provide action, see help'
      failure = true
    end

    if (options[:action] == 'export') && options[:export_format].nil?
      Log.error 'format not provided'
      failure = true
    end

    if options[:project_file].nil?
      Log.error 'need to provide project file, see help'
      failure = true
    end

    if (options[:action] == 'list') && options[:doc].nil?
      Log.error 'need to provide a doc for list requirement'
      failure = true
    end

    return unless failure

    exit EXIT_FAILURE
  end

  # load project according to +options+ hash
  def load_project_check_working_dir(options)
    project = Project.new options[:project_file]
    project.read
    if project.loaded? # && Dir.exist?(project.working_dir)
      @working_dir = project.working_dir
      Log.info "project file: #{options[:project_file]}"
    else
      Log.error "project file is not valid or working dir doesn't exist"
      project = nil
    end
    project
  end

  # parse action argument
  # +options+ hash of option given in command line
  # +project+ Project class object
  def parse_and_launch_action(options)
    case options[:action]
    when 'export'
      check_export_output_arg(options)
      traca_report = generate_traceability(options)
      generate_export(options, traca_report) unless traca_report.nil?
    when 'status'
      traca_report = generate_traceability(options)
      display_status(traca_report) unless traca_report.nil?
    when 'list'
      doc_req = generate_doc_req(options)
      display_doc_req(doc_req) unless doc_req.nil?
    when 'clean'
      clean_intermediate_file
    else
      Log.error 'Unknown action'
    end
  end

  # check if output is given
  def check_export_output_arg(options)
    if options[:output_folder].nil?
      Log.error 'no output folder given, see help'
      exit EXIT_FAILURE
    else
      check_if_folder_exist_or_create_it(options[:output_folder])
      @output_folder = options[:output_folder]
    end

    check_output_file(options)
  end

  def check_output_file(options)
    if options[:export_format] == 'xlsx' && options[:output_file].nil?
      Log.error 'for xlsx, provide a output file , see help'
      exit EXIT_FAILURE
    else
      @output_file = options[:output_file]
    end
  end

  def check_if_folder_exist_or_create_it(folder_name)
    return if Dir.exist?(folder_name)

    begin
      Dir.mkdir(folder_name)
    rescue StandardError => e
      Log.error "unable to create folder #{folder_name}, #{e}"
      exit EXIT_FAILURE
    end
  end

  # launch effectif traceablity action
  def generate_traceability(options)
    traca_report = nil
    if !options[:relationship].nil?
      Log.info "Generate traceability #{options[:relationship]}"
      traca = TracaGenerator.new(@project)
      traca_report = traca.generate_traceability(options[:relationship], options[:plugins_path])
      Log.debug_pp traca_report unless traca_report.nil?
    else
      Log.error 'Error, no relationship given'
      exit EXIT_FAILURE
    end
    traca_report
  end

  def generate_export(options, traca_report)
    # pp r
    if traca_report.nil?
      Log.error 'Unable to create traceability data'
    else
      export = create_export(options[:export_format])
      export.export_traca_report report: traca_report, output_folder: @output_folder, output_file: @output_file
    end
  end

  def generate_doc_req(options)
    traca = TracaGenerator.new(@project)
    doc_req = traca.generate_doc_req_list(options[:doc], options[:plugins_path])
    Log.error "Document '#{options[:doc]}' doesn't exist" if doc_req.nil?

    doc_req
  end

  def clean_intermediate_file
    traca_ctrl = TracaGenerator.new(@project)
    traca_ctrl.clean
  end

  def create_export(format)
    export_gen = nil
    case format
    when 'xlsx'
      Log.info 'xlsx format'
      export_gen = ExportXlsx.new
    when 'csv'
      Log.info 'csv format'
      export_gen = ExportCsv.new
    else
      Log.error "unknown format #{format}"
      exit EXIT_FAILURE
    end
    export_gen
  end

  def display_status(traca_report)
    DisplayStatusReq.display(traca_report)
  end

  def display_doc_req(doc_req)
    doc_req.display
  end
end

if $PROGRAM_NAME == __FILE__
  app = Main.new
  app.main
end
