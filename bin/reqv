#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative '../lib/project'
require_relative '../lib/traca_gen'
require_relative '../lib/export'
require_relative '../lib/log'

# main application class
class Main
  EXIT_FAILURE = 1

  def initialize
    @working_dir = ''
    @output_folder = ''
    @project = nil
  end

  # main entry point function
  # read the command-line argument
  # check them
  # and execute requested action
  def main
    options = read_args
    check_options(options)
    initialize_log_level(options)
    @project = load_project_check_working_dir(options)
    parse_and_launch_action(options)
  end

  # This method read command-line arguments
  # and returns +options+ hash of argument
  def read_args # rubocop:disable Metrics/MethodLength, Metrics/AbcSize
    options = {}
    OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} "
      opts.on('-pPROJECT_FILE', '--project=PROJECT_FILE', 'provide project file') do |n|
        options[:project_file] = n
      end
      opts.on('-rRELATIONSHIP', '--relationship=RELATIONSHIP', 'concerned traceability to check/export') do |n|
        options[:relationship] = n
      end
      opts.on('-aACTION', '--action=ACTION', 'action to launch (check/export)') do |n|
        options[:action] = n
      end
      opts.on('-oOUTPUT_FOLDER', '--output-folder=OUTPUT_FOLDER', 'folder where stored result') do |n|
        options[:output_folder] = n
      end
      opts.on('-fOUTPUT_FILE', '--output-file=OUTPUT_FILE', 'file where stored result') do |n|
        options[:output_file] = n
      end
      opts.on('-d', '--[no-]debug', 'Run with debug info') do |n|
        options[:debug] = n
      end
      opts.on('-v', '--[no-]verbose', 'Run with verbose info') do |n|
        options[:verbose] = n
      end
    end.parse!
    # pp options
    options
  end

  def initialize_log_level(options)
    Log.verbose_level = Log::LOG_LEVEL_NONE
    Log.verbose_level = Log::LOG_LEVEL_INFO unless options[:verbose].nil?
    Log.verbose_level = Log::LOG_LEVEL_DBG unless options[:debug].nil?
  end

  # check if given +options+ (hash data come from command-line)
  # are correct
  # return to shell if mandatory option are not given
  def check_options(options)
    if options[:action].nil?
      Log.error 'need to provide action, see help'
      exit EXIT_FAILURE
    end

    return unless options[:project_file].nil?

    Log.error 'need to provide project file, see help'
    exit EXIT_FAILURE
  end

  # load project according to +options+ hash
  def load_project_check_working_dir(options)
    project = Project.new options[:project_file]
    if project.loaded? && Dir.exist?(project.working_dir)
      @working_dir = project.working_dir
      Log.info "project file: #{options[:project_file]}"
    else
      Log.error "project file is not valid or working dir doesn't exist"
      exit EXIT_FAILURE
    end
    project
  end

  # parse action argument
  # +options+ hash of option given in command line
  # +project+ Project class object
  def parse_and_launch_action(options)
    action = options[:action]
    # pp actions

    case action
    when 'export'
      check_export_output_arg(options)
      generate_traceability(options[:relationship])
    when 'status'
      Log.info 'status'
    else
      Log.error 'Unknown action'
    end
  end

  # check if output is given
  def check_export_output_arg(options)
    if options[:output_folder].nil?
      Log.error 'no output folder given, see help'
      exit EXIT_FAILURE
    else
      check_if_folder_exist_or_create_it(options[:output_folder])
      @output_folder = options[:output_folder]
    end
  end

  def check_if_folder_exist_or_create_it(folder_name)
    return if Dir.exist?(folder_name)

    begin
      Dir.mkdir(folder_name)
    rescue StandardError => e
      Log.error "unable to create folder #{folder_name}, #{e}"
      exit EXIT_FAILURE
    end
  end

  # launch effectif traceablity action
  def generate_traceability(relationship)
    # p 'GO'
    if !relationship.nil?
      traca = TracaGenerator.new(@project)
      r = traca.generate_traceability(relationship)
      # pp r
      if r.nil?
        Log.error 'Unable to create traceability data'
      else
        export = Export.new(r, @output_folder)
        export.export_result r
      end
      # pp traca
    else
      Log.error 'Error, no relationship given'
      exit EXIT_FAILURE
    end
  end
end

app = Main.new
app.main
